#!/usr/bin/env bash
# Compatible with bash and zsh.
PACKAGE_VERSION="0.4.0"
set -e
set -u
if command -v setopt >/dev/null 2>&1; then
  setopt pipefail
else
  set -o pipefail 2>/dev/null || true
fi

PORT=9222
WINDOWS_CHROME_PATH='C:\Program Files\Google\Chrome\Application\chrome.exe'
FIREWALL_RULE_NAME='Chrome Remote Debug'
PID_FILE="/tmp/start-chrome-wsl.pids"
HOST_IP=""
BROWSER_VERSION=""
OK_MARK="✅"
WARN_MARK="❗"
ERR_MARK="❌"

ok() {
  local prefix="${CONTAINER_LABEL:+[${CONTAINER_LABEL}] }"
  echo "${OK_MARK} ${prefix}$*"
}

err() {
  local prefix="${CONTAINER_LABEL:+[${CONTAINER_LABEL}] }"
  echo "${ERR_MARK} ${prefix}$*" >&2
}

warn() {
  local prefix="${CONTAINER_LABEL:+[${CONTAINER_LABEL}] }"
  echo "${WARN_MARK} ${prefix}$*" >&2
}

set_pid() {
  # Stores or updates a PID value in the temp PID file.
  local key=$1
  local value=$2
  [[ -z "${value:-}" ]] && return
  touch "$PID_FILE"
  if grep -q "^${key}=" "$PID_FILE" 2>/dev/null; then
    sed -i.bak "s/^${key}=.*/${key}=${value}/" "$PID_FILE" && rm -f "${PID_FILE}.bak"
  else
    echo "${key}=${value}" >>"$PID_FILE"
  fi
}

get_pid() {
  local key=$1
  [[ -f "$PID_FILE" ]] || return 0
  sed -n "s/^${key}=//p" "$PID_FILE" | head -n1
}

clear_pid() {
  local key=$1
  [[ -f "$PID_FILE" ]] || return 0
  sed -i.bak "/^${key}=/d" "$PID_FILE"
  rm -f "${PID_FILE}.bak"
  if [[ ! -s "$PID_FILE" ]]; then
    rm -f "$PID_FILE"
  fi
}

stop_socat() {
  local pattern="socat TCP-LISTEN:${PORT},fork,reuseaddr"
  if pgrep -f "$pattern" >/dev/null 2>&1; then
    pkill -f "$pattern" || true
    ok "Stopped socat forwarding for port ${PORT}."
    clear_pid "SOCAT_PID"
  else
    ok "No socat forwarding for port ${PORT} is running."
  fi
}

run_powershell() {
  # Runs a PowerShell command from WSL. If RUN_AS_ADMIN=1, invoke via Start-Process -Verb RunAs
  # and capture output through a temp script/output file to mirror direct execution.
  local ps_cmd="$*"

  if [[ "${RUN_AS_ADMIN:-}" == "1" ]]; then
    local out_file ps_file win_out win_ps
    mkdir -p /mnt/c/Temp
    out_file=$(mktemp -p /mnt/c/Temp chrome-wsl-out-XXXXXX)
    ps_file=$(mktemp -p /mnt/c/Temp --suffix=.ps1 chrome-wsl-XXXXXX)
    win_out=$(wslpath -w "$out_file")
    win_ps=$(wslpath -w "$ps_file")

    {
      echo "& {"
      echo "  ${ps_cmd}"
      echo "} | Out-File -FilePath \"${win_out}\" -Encoding UTF8"
    } >"$ps_file"

    powershell.exe -NoLogo -NoProfile -NonInteractive -Command "Start-Process -FilePath 'powershell' -Verb RunAs -ArgumentList '-NoLogo','-NoProfile','-NonInteractive','-File','\"${win_ps}\"' -WindowStyle Hidden -Wait"
    cat "$out_file"
    rm -f "$out_file" "$ps_file"
  else
    powershell.exe -NoLogo -NoProfile -NonInteractive -Command "$ps_cmd"
  fi
}

CONFIRM_MARK="❔"
confirm() {
  local prompt=$1
  local reply
  local prefix="${CONTAINER_LABEL:+[${CONTAINER_LABEL}] }"
  read -r -p "${CONFIRM_MARK} ${prefix}${prompt} [y/N] " reply
  [[ "${reply}" =~ ^[Yy]$ ]]
}

version_suffix() {
  if [[ -n "${BROWSER_VERSION:-}" ]]; then
    printf " (Chrome %s)" "$BROWSER_VERSION"
  fi
}

chrome_running() {
  run_powershell "if (Get-Process -Name chrome -ErrorAction SilentlyContinue) { exit 0 } else { exit 1 }"
}

port_listening_by_chrome() {
  local attempts=5
  local delay=1
  local i
  for ((i=1; i<=attempts; i++)); do
    if run_powershell "if (Get-NetTCPConnection -LocalPort ${PORT} -ErrorAction SilentlyContinue | Where-Object { \$p = Get-Process -Id \$_.OwningProcess -ErrorAction SilentlyContinue; \$p -and \$p.Name -eq 'chrome' }) { exit 0 } else { exit 1 }"; then
      return 0
    fi
    sleep "$delay"
  done
  return 1
}

port_listening_info() {
  run_powershell "\$conns = Get-NetTCPConnection -LocalPort ${PORT} -ErrorAction SilentlyContinue | Select-Object -Property LocalAddress,LocalPort,RemoteAddress,RemotePort,State,OwningProcess; foreach (\$c in \$conns) { \$p = Get-Process -Id \$c.OwningProcess -ErrorAction SilentlyContinue; \$name = if (\$p) { \$p.Name } else { 'unknown' }; Write-Output (\"{0}:{1} owner={2} pid={3} state={4}\" -f \$c.LocalAddress, \$c.LocalPort, \$name, \$c.OwningProcess, \$c.State) }"
}

get_browser_version() {
  local host_ip=${1:-$HOST_IP}
  [[ -z "${host_ip:-}" ]] && return 0
  curl -s "http://${host_ip}:${PORT}/json/version" \
    | sed -n "s/.*\"Browser\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/p" \
    | head -n 1
}

get_wsl_host_ip() {
  local host_ip
  host_ip=$(ip route | awk '/^default via / {print $3; exit}')
  if [[ -z "${host_ip:-}" ]]; then
    err "Could not determine Windows host IP from default route."
    return 1
  fi
  printf '%s' "$host_ip"
}

check_portproxy() {
  local host_ip=$1
  local output regex
  output=$(run_powershell "netsh interface portproxy show all" | tr -d '
')
  regex="${host_ip//./\.}[[:space:]]+${PORT}[[:space:]]+127\.0\.0\.1[[:space:]]+${PORT}"
  if echo "$output" | grep -Eq "$regex"; then
    ok "Portproxy ${host_ip}:${PORT} -> 127.0.0.1:${PORT} is configured."
    return 0
  fi

  warn "Portproxy on ${host_ip}:${PORT} is missing; attempting to create it (may prompt for admin)."
  if RUN_AS_ADMIN=1 run_powershell "netsh interface portproxy add v4tov4 listenaddress=${host_ip} listenport=${PORT} connectaddress=127.0.0.1 connectport=${PORT}"; then
    output=$(run_powershell "netsh interface portproxy show all" | tr -d '
')
    if echo "$output" | grep -Eq "$regex"; then
      ok "Created portproxy ${host_ip}:${PORT} -> 127.0.0.1:${PORT}."
      return 0
    fi
  fi

  cat <<EOF
${ERR_MARK} Portproxy on ${host_ip}:${PORT} is missing.
Run this in an **admin PowerShell** window:
netsh interface portproxy add v4tov4 listenaddress=${host_ip} listenport=${PORT} connectaddress=127.0.0.1 connectport=${PORT}
EOF
  return 1
}

check_firewall_rule() {
  local rule_check_cmd="\$rule='${FIREWALL_RULE_NAME}'; if (Get-NetFirewallRule -DisplayName \$rule -ErrorAction SilentlyContinue) { exit 0 } else { exit 1 }"

  if run_powershell "${rule_check_cmd}"; then
    ok "Firewall rule \"${FIREWALL_RULE_NAME}\" exists."
    return 0
  fi

  warn "Firewall rule \"${FIREWALL_RULE_NAME}\" is missing; attempting to create it (may prompt for admin)."
  if RUN_AS_ADMIN=1 run_powershell "New-NetFirewallRule -DisplayName \"${FIREWALL_RULE_NAME}\" -Direction Inbound -LocalPort ${PORT} -Protocol TCP -Action Allow" \
     && run_powershell "${rule_check_cmd}"; then
    ok "Created firewall rule \"${FIREWALL_RULE_NAME}\"."
    return 0
  fi

  cat <<EOF
${ERR_MARK} Failed to create firewall rule "${FIREWALL_RULE_NAME}" automatically.
Run this in an **admin PowerShell** window:
New-NetFirewallRule -DisplayName "${FIREWALL_RULE_NAME}" -Direction Inbound -LocalPort ${PORT} -Protocol TCP -Action Allow
EOF
  return 1
}

uninstall_firewall_rule() {
  local rule_check_cmd="\$rule='${FIREWALL_RULE_NAME}'; if (Get-NetFirewallRule -DisplayName \$rule -ErrorAction SilentlyContinue) { exit 0 } else { exit 1 }"

  if ! run_powershell "${rule_check_cmd}"; then
    ok "Firewall rule \"${FIREWALL_RULE_NAME}\" is already absent."
    return 0
  fi

  if ! confirm "Remove firewall rule \"${FIREWALL_RULE_NAME}\"?"; then
    ok "Skipped firewall rule removal."
    return 0
  fi

  if RUN_AS_ADMIN=1 run_powershell "Remove-NetFirewallRule -DisplayName \"${FIREWALL_RULE_NAME}\"" \
     && ! run_powershell "${rule_check_cmd}"; then
    ok "Removed firewall rule \"${FIREWALL_RULE_NAME}\"."
  else
    err "Failed to remove firewall rule \"${FIREWALL_RULE_NAME}\"."
  fi
}

uninstall_socat() {
  if ! command -v socat >/dev/null 2>&1; then
    ok "socat is not installed; nothing to remove."
    return 0
  fi

  if ! confirm "Remove socat package (sudo apt-get remove -y socat)?"; then
    ok "Skipped socat removal."
    return 0
  fi

  stop_socat
  if sudo apt-get remove -y socat; then
    ok "Removed socat package."
  else
    err "Failed to remove socat package."
  fi
}

# Remove portproxy entry
uninstall_portproxy() {
  local host_ip=${1:-$HOST_IP}
  if [[ -z "${host_ip:-}" ]]; then
    host_ip=$(get_wsl_host_ip)
  fi
  local output regex
  output=$(run_powershell "netsh interface portproxy show all" | tr -d '\r')
  regex="${host_ip//./\\.}[[:space:]]+${PORT}[[:space:]]+127\\.0\\.0\\.1[[:space:]]+${PORT}"
  if ! echo "$output" | grep -Eq "$regex"; then
    ok "Portproxy ${host_ip}:${PORT} is already absent."
    return 0
  fi

  if ! confirm "Remove portproxy ${host_ip}:${PORT} -> 127.0.0.1:${PORT}?"; then
    ok "Skipped portproxy removal."
    return 0
  fi

  if RUN_AS_ADMIN=1 run_powershell "netsh interface portproxy delete v4tov4 listenaddress=${host_ip} listenport=${PORT}" \
     && ! (run_powershell "netsh interface portproxy show all" | tr -d '\r' | grep -Eq "$regex"); then
    ok "Removed portproxy ${host_ip}:${PORT} -> 127.0.0.1:${PORT}."
  else
    err "Failed to remove portproxy ${host_ip}:${PORT}."
  fi
}

ensure_socat() {
  if command -v socat >/dev/null 2>&1; then
    ok "socat is already installed."
    return 0
  fi

  err "socat not found. Installing via apt..."
  sudo apt-get update
  sudo apt-get install -y socat
}

start_socat() {
  local host_ip=$1
  if pgrep -f "socat TCP-LISTEN:${PORT},fork,reuseaddr TCP:${host_ip}:${PORT}" >/dev/null 2>&1; then
    ok "socat forwarding for port ${PORT} already running."
    return 0
  fi

  nohup socat "TCP-LISTEN:${PORT},fork,reuseaddr" "TCP:${host_ip}:${PORT}" >/tmp/socat-9222.log 2>&1 &
  set_pid "SOCAT_PID" "$!"
  ok "Started socat (logging to /tmp/socat-9222.log)."
}

is_docker() {
  [[ -f /.dockerenv ]] && return 0
  grep -qaE 'docker|containerd|kubepods' /proc/1/cgroup 2>/dev/null
}

container_exec() {
  local container=$1; shift
  local script_path
  script_path=$(readlink -f "$0")
  ensure_docker
  local tty_flag="-i"
  if [ -t 0 ]; then
    tty_flag="-it"
  fi
  if ! cat "$script_path" | docker exec -i "${container}" sh -c "cat > /tmp/chrome-wsl.sh"; then
    err "Failed to copy script into container ${container}."
    exit 1
  fi
  local inner_cmd="CONTAINER_LABEL=${container} chmod +x /tmp/chrome-wsl.sh && CONTAINER_LABEL=${container} /tmp/chrome-wsl.sh $*"
  docker exec ${tty_flag} "${container}" sh -lc "${inner_cmd}"
}

get_docker_host_ip() {
  getent hosts host.docker.internal 2>/dev/null | awk '{print $1; exit}'
}

ensure_docker() {
  if command -v docker >/dev/null 2>&1; then
    return 0
  fi
  err "Docker CLI is required for --container."
  exit 1
}

stop_chrome() {
  local chrome_pid
  chrome_pid=$(get_pid "CHROME_PID")
  if [[ -z "${chrome_pid:-}" ]]; then
    ok "No tracked Chrome PID found; skipping Chrome stop."
    return 0
  fi

  if run_powershell "if (Get-Process -Id ${chrome_pid} -ErrorAction SilentlyContinue) { Stop-Process -Id ${chrome_pid} -Force; exit 0 } else { exit 1 }"; then
    ok "Stopped tracked Chrome process (pid ${chrome_pid})."
  else
    ok "Tracked Chrome PID ${chrome_pid} is not running."
  fi
  clear_pid "CHROME_PID"
}

start_chrome() {
  local chrome_cmd
  chrome_cmd="\$args = @(\"--remote-debugging-port=${PORT}\", \"--no-first-run\", \"--no-default-browser-check\", \"--user-data-dir=\$env:TEMP\\chrome-profile-stable\"); \$p = Start-Process -FilePath \"${WINDOWS_CHROME_PATH}\" -ArgumentList \$args -PassThru; Write-Output \$p.Id"

  if [[ -n "$(get_pid "CHROME_PID")" ]]; then
    if port_listening_by_chrome; then
      ok "Port ${PORT} already listening on Windows (owned by chrome); assuming ready. Skipping launch (tracked pid $(get_pid "CHROME_PID"))."
      return 0
    fi

    if chrome_running; then
      err "Chrome is running (tracked pid $(get_pid "CHROME_PID")), but port ${PORT} is not listening. You may need to start Chrome with --remote-debugging-port=${PORT}."
    fi
  fi

  local chrome_pid
  chrome_pid=$(run_powershell "$chrome_cmd" | tr -d '\r' | head -n 1)
  if [[ -n "${chrome_pid:-}" ]]; then
    set_pid "CHROME_PID" "$chrome_pid"
    ok "Launched Chrome (pid ${chrome_pid}) with remote debugging."
  else
    err "Launched Chrome but could not determine PID."
  fi

  if port_listening_by_chrome; then
    ok "Chrome is listening on port ${PORT}."
  else
    err "Chrome launch did not open port ${PORT}; verify remote-debugging flag or check for conflicts."
    port_listening_info
  fi
}

ensure_wsl() {
  if grep -qEi 'Microsoft|WSL' /proc/version >/dev/null 2>&1; then
    return 0
  fi
  err "This tool must be run inside WSL; exiting."
  exit 1
}

main() {
  local container="" uninstall_flag=0 stop_flag=0
  for arg in "$@"; do
    case "$arg" in
      --container=*) container=${arg#*=} ;;
      --uninstall) uninstall_flag=1 ;;
      --stop) stop_flag=1 ;;
    esac
  done

  if [[ "${1-}" == "--version" || "${1-}" == "-V" ]]; then
    echo "chrome-wsl ${PACKAGE_VERSION:-unknown}"
    exit 0
  fi

  if is_docker && [[ -n "$container" ]]; then
    err "--container is only supported when running in WSL, not inside Docker."
    exit 1
  fi

  if is_docker; then
    if [[ $uninstall_flag -eq 1 ]]; then
      uninstall_socat
      exit 0
    fi

    if [[ $stop_flag -eq 1 ]]; then
      stop_socat
      exit 0
    fi

    HOST_IP=$(get_docker_host_ip)
    if [[ -z "${HOST_IP:-}" ]]; then
      err "Could not resolve host.docker.internal inside Docker."
      exit 1
    fi

    ensure_socat
    start_socat "$HOST_IP"
    exit 0
  fi

  ensure_wsl

  if [[ $uninstall_flag -eq 1 ]]; then
    uninstall_portproxy
    uninstall_firewall_rule
    uninstall_socat
    if [[ -n "$container" ]]; then
      container_exec "$container" --uninstall
    fi
    exit 0
  fi

  if [[ $stop_flag -eq 1 ]]; then
    stop_chrome
    stop_socat
    if [[ -n "$container" ]]; then
      container_exec "$container" --stop
    fi
    exit 0
  fi

  HOST_IP=$(get_wsl_host_ip)
  local host_ip="$HOST_IP"
  ok "Detected Windows host IP: ${host_ip}"

  check_portproxy "$host_ip" || exit 1
  check_firewall_rule || exit 1
  ensure_socat
  start_socat "$host_ip"
  start_chrome

  if [[ -n "$container" ]]; then
    container_exec "$container"
  fi
}

main "$@"